= Mockito Tutorial with JUnit 5
:toc: right
:toclevels:5
:sectnums:

Mockito is a Java framework that allows the creation of mock objects for unit testing. It works especially well with JUnit 5.

== Prerequisites

Add the following Maven dependencies in your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.0.0</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <version>5.9.1</version>
    <scope>test</scope>
</dependency>
----

== Basic Mock Example

[source,java]
----
import org.junit.jupiter.api.Test;
import java.util.List;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class BasicMockTest {

    @Test
    void testMockList() {
        List<String> mockedList = mock(List.class);
        when(mockedList.get(0)).thenReturn("Hello Mockito");

        assertEquals("Hello Mockito", mockedList.get(0));
        assertNull(mockedList.get(1)); // Unstubbed call returns null
    }
}
----

== Verify Method Calls

[source,java]
----
public class VerifyMethodCallTest {

    @Test
    void testVerifyCalls() {
        List<String> mockedList = mock(List.class);

        mockedList.add("Apple");
        mockedList.add("Banana");

        verify(mockedList).add("Apple");
        verify(mockedList).add("Banana");
    }
}
----

== Mocking Service Layer Dependency

[source,java]
----
class UserService {
    public String getUserName(int userId) {
        return "Real User";
    }
}

class UserController {
    private final UserService service;

    public UserController(UserService service) {
        this.service = service;
    }

    public String fetchUserName(int id) {
        return service.getUserName(id);
    }
}

public class MockServiceTest {

    @Test
    void testServiceMock() {
        UserService mockService = mock(UserService.class);
        when(mockService.getUserName(1)).thenReturn("Mocked User");

        UserController controller = new UserController(mockService);
        assertEquals("Mocked User", controller.fetchUserName(1));
    }
}
----

== Mocking Exceptions

[source,java]
----
import org.junit.jupiter.api.Test;
import java.util.List;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class ExceptionMockTest {

    @Test
    void testThrowingException() {
        List<String> mockedList = mock(List.class);

        // Configure the mock to throw an exception when get(1) is called
        when(mockedList.get(1)).thenThrow(new RuntimeException("Item not found"));

        try {
            mockedList.get(1); // Call the method that should throw the exception
            fail("Expected RuntimeException was not thrown"); // Fail the test if no exception is thrown
        } catch (RuntimeException ex) {
            assertEquals("Item not found", ex.getMessage()); // Verify the exception message
        }
    }
}
----

== Verifying Number of Invocations

[source,java]
----
public class VerifyTimesTest {

    @Test
    void testMultipleCalls() {
        List<String> mockedList = mock(List.class);

        mockedList.add("One");
        mockedList.add("Two");
        mockedList.add("Two");

        verify(mockedList, times(1)).add("One");
        verify(mockedList, times(2)).add("Two");
    }
}
----

== Resetting a Mock

[source,java]
----
public class ResetMockTest {

    @Test
    void testReset() {
        List<String> mockedList = mock(List.class);

        when(mockedList.size()).thenReturn(5);
        assertEquals(5, mockedList.size());

        reset(mockedList);
        assertEquals(0, mockedList.size()); // Unstubbed after reset
    }
}
----



##############################################

---

== Mock and InjectMocks Example

We have a `BookService` class that depends on `BookDAO` to get books. We want to test `BookService` in isolation using Mockito.

*Step 1: Create the Entity*

[source, java]
----
public class Book {
    private int id;
    private String title;

    public Book(int id, String title) {
        this.id = id;
        this.title = title;
    }

    public int getId() { return id; }
    public String getTitle() { return title; }

    @Override
    public String toString() {
        return "Book{id=" + id + ", title='" + title + "'}";
    }
}
----

*Step 2: Create DAO Interface*

[source, java]
----
import java.util.List;

public interface BookDAO {
    List<Book> getAllBooks();
}
----

*Step 3: Create Service Class*

[source, java]
----
import java.util.List;

public class BookService {
    private BookDAO bookDAO;

    public BookService(BookDAO bookDAO) {
        this.bookDAO = bookDAO;
    }

    public List<Book> fetchAllBooks() {
        return bookDAO.getAllBooks();
    }
}
----

*Step 4: Unit Test with @Mock and @InjectMocks*

[source, java]
----
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class BookServiceTest {

    @Mock
    private BookDAO bookDAO;

    @InjectMocks
    private BookService bookService;

    @Test
    public void testFetchAllBooks() {
        // Arrange
        List<Book> mockBooks = Arrays.asList(
            new Book(1, "Clean Code"),
            new Book(2, "Effective Java")
        );
        when(bookDAO.getAllBooks()).thenReturn(mockBooks);

        // Act
        List<Book> books = bookService.fetchAllBooks();

        // Assert
        assertEquals(2, books.size());
        assertEquals("Clean Code", books.get(0).getTitle());
    }
}
----

*Explanation*

* `@Mock` – creates a mock of the `BookDAO` interface.
* `@InjectMocks` – injects the mocked `BookDAO` into the `BookService` instance.
* `when(...).thenReturn(...)` – sets up the mocked behavior.
* `@ExtendWith(MockitoExtension.class)` – enables annotation processing for Mockito in JUnit 5.

*Dependencies (Maven)*

Add the following dependencies to your `pom.xml`:

[source, xml]
----
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.11.0</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <version>5.11.0</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.10.0</version>
    <scope>test</scope>
</dependency>
----

Let me know if you want the same example with constructor or setter-based injection instead.
```



##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


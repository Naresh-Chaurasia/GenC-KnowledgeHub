= Gen-C Spring Boot 1
:toc: right
:toclevels: 5
:sectnums: 5

== Spring Boot

Spring Boot is a *framework* built on top of the Spring Framework that simplifies the development of Spring-based applications by eliminating boilerplate code and configurations.

*Key Features*

* *Auto Configuration* – Automatically configures your Spring application based on the dependencies you add.
* *Standalone Applications* – Run Spring applications with a simple `main()` method.
* *Embedded Servers* – No need for external web servers like Tomcat or Jetty; they're embedded.
* *Production Ready* – Includes features like metrics, health checks, and externalized configuration.
* *Minimal Configuration* – Convention-over-configuration approach speeds up development.

*Why Use Spring Boot?*

* Reduces development time and effort.
* No need to write complex XML configuration.
* Easily create REST APIs, microservices, or full-stack web apps.
* Integrated tools and starter dependencies make development smooth.

*Hello World Example*

[source,java]
----
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
----

Run the application, and you’ve got a Spring-powered web service running in seconds!

*When to Use Spring Boot?*

* When you want to quickly bootstrap a Spring application.
* When building microservices or REST APIs.
* When you prefer *convention over configuration*.

##############################################

== Why Spring Boot

=== Dependency Management

Spring Boot simplifies dependency management by offering *starter dependencies*, which are curated sets of commonly used libraries.

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
----

*Benefits:*

* Automatically pulls in required libraries (like Tomcat, Jackson, Spring MVC, etc.).
* Reduces version conflicts and manual dependency management.
* Easy upgrades and consistent dependency versions through a *parent POM*.

##############################################

=== Web App Configuration ⚠️

*Web App Configuration in MVC Projects Using `web.xml`*

Traditionally, Spring MVC required `web.xml` for servlet and filter mappings.

[source,xml]
----
<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
----

In Spring Boot:

* No need for `web.xml`.
* Use annotations like `@SpringBootApplication` and run with a `main()` method.

[source,java]
----
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
----

*Benefits:*

* Reduces boilerplate.
* Uses embedded servlet containers (like Tomcat) without manual setup.
* Rapid prototyping with minimal configuration.

=== Manage Spring Beans

*Manage Spring Beans Using `context.xml`*

In traditional Spring applications, beans were defined in `applicationContext.xml`.

[source,xml]
----
<bean id="myService" class="com.example.MyService"/>
----

In Spring Boot:

* Use annotations like `@Component`, `@Service`, and `@Autowired`.

[source,java]
----
@Service
public class MyService {
}
----

[source,java]
----
@RestController
public class MyController {
    @Autowired
    private MyService myService;
}
----

*Benefits:*

* No need for XML-based configuration.
* Component scanning and auto-configuration reduce setup complexity.

##############################################

=== Non-Functional Requirements

*Implement Non-Functional Requirements like Metrics and Health Checks*

Spring Boot includes the *Actuator* module to expose endpoints for monitoring and management.

Add dependency:

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
----

Access endpoints:

* `/actuator/health` – Application health status.
* `/actuator/metrics` – Metrics like memory usage, request count, etc.

*Benefits:*

* No need to write custom code for health checks or metrics.
* Easy integration with monitoring tools like Prometheus, Grafana, and ELK stack.
* Secure and configurable endpoint exposure.

##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################


##############################################

##############################################

=== Spring Boot Starter Projects

Spring Boot provides pre-configured starter dependencies to quickly set up common project types.
These starters group commonly used libraries, so you don’t have to manually list them one by one.

* Example: `spring-boot-starter-web` includes Spring MVC, Jackson (for JSON), and an embedded Tomcat server.
* Just add the required starter in `pom.xml` and start coding — no need for complex setup.

=== Spring Boot Auto Configuration

*Spring Boot Auto Configuration* automatically configures your Spring application based on the dependencies present in the classpath.
It reduces the need for manual configuration in `@Configuration` classes or XML files.

Instead of writing boilerplate configuration, Spring Boot tries to guess and configure the beans you are likely to need.

*How It Works*

* Spring Boot uses the `@EnableAutoConfiguration` annotation (usually included in `@SpringBootApplication`) to trigger auto configuration.
* It checks the classpath, application properties, and default configurations to decide what to configure.

*Example*

Suppose you include the `spring-boot-starter-web` dependency:

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
----

Spring Boot automatically:

* Configures a `DispatcherServlet`
* Sets up `Tomcat` as the default web server
* Registers default `Jackson` JSON converters
* Creates `RestTemplate` and `WebMvcConfigurer` beans

All without writing any additional configuration!

*Sample Application*

[source,java]
----
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
----

You don’t need to define any additional beans for web configuration — Spring Boot handles it automatically!

==== Customizing Auto Configuration

You can override defaults using `application.properties` or `application.yml`:

[source,properties]
----
server.port=8081
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
----

*Disabling Auto Configuration (Optional)*

If you want to exclude a specific auto configuration:

[source,java]
----
@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })
public class MyApplication {
    ...
}
----

*Summary*

* Auto Configuration reduces manual setup and speeds up development.
* It is flexible and can be overridden easily.
* It relies on classpath detection and sensible defaults to work efficiently.

##############################################



=== Spring Boot DevTools

DevTools helps speed up development by providing helpful features like:

* *Automatic Restart* – Restarts the application when code changes.
* *LiveReload* – Automatically refreshes browser when templates or static files change.
* *Disabling Caching* – Makes sure changes to templates are picked up immediately during development.

To use DevTools, add the following dependency in `pom.xml` (only used during development):

[source, xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
</dependency>
----


##############################################

== Spring Boot Profiles

image::img/profiles.png[]

---

Spring Boot provides a way to create environment-specific configurations using *profiles*. Common use cases include setting different properties for `dev`, `test`, and `prod` environments.

*1. Define Application Properties for Different Profiles*

Create different property files in the `src/main/resources` folder:

* application.properties (default)
* application-dev.properties
* application-test.properties
* application-prod.properties

Example: `application-dev.properties`

[source, properties]
----
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/dev_db
----

Example: `application-prod.properties`

[source, properties]
----
server.port=9090
spring.datasource.url=jdbc:mysql://prod-server:3306/prod_db
----

*2. Activate a Profile*

You can activate a profile in multiple ways:

*a. Using application.properties*

[source, properties]
----
spring.profiles.active=dev
----

*b. Using Command Line*

----
$ java -jar myapp.jar --spring.profiles.active=prod
----

*c. Using Environment Variable*

----
SPRING_PROFILES_ACTIVE=dev
----

*NOTE*

The way I can do that is by saying spring.profiles.active=prod. So if I configure a specific profile, the values from the default configuration which is present in application.properties and the values from application-prod.properties are merged together. *Whatever is configured in application-prod.properties, that specific profile has higher priority*. So over here we are saying logging.level.org.springframework=info, and the same logging level in the default file is debug. So the value in the profile application-prod.properties has higher priority. So you'd see that that gets higher priority and only info log would be printed now.


*3. Use `@Profile` Annotation in Java Classes*

You can enable beans only for specific profiles:

[source, java]
----
@Component
@Profile("dev")
public class DevDataSourceConfig implements DataSourceConfig {
// dev-specific configuration
}
----

[source, java]
----
@Component
@Profile("prod")
public class ProdDataSourceConfig implements DataSourceConfig {
// prod-specific configuration
}
----

*4. Check Active Profile Programmatically (Optional)*

[source, java]
----
@Autowired
private Environment env;

public void checkProfile() {
String[] profiles = env.getActiveProfiles();
Arrays.stream(profiles).forEach(System.out::println);
}
----

*5. Output Example*

When you run with `--spring.profiles.active=prod`, the application will:

* Use properties from `application-prod.properties`
* Instantiate beans with `@Profile("prod")`
* Possibly print:
----
prod
----

*Summary*

* Profiles help manage environment-specific configurations.
* Property files and beans can be customized per profile.
* Profiles can be activated via properties, command line, or environment variables.

##############################################

== Spring Boot Actuator

Spring Boot Actuator provides ready-to-use features to help you monitor and manage your application in production. It exposes various REST endpoints to give insights into the running application.

*Key Features*

* Exposes endpoints for monitoring and managing the application.
* Provides health checks, metrics, environment details, thread dumps, and more.
* Easily customizable and secure.
* Integrates well with Spring Security.

*How to Add Actuator to Your Project*

Add the following dependency in `pom.xml`:

[source, xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
----

*Common Actuator Endpoints*

|===
| Endpoint | Description

| `/actuator/health` | Shows application health status.
| `/actuator/info` | Displays custom information.
| `/actuator/metrics` | Shows application metrics (e.g., JVM memory, CPU, HTTP requests).
| `/actuator/env` | Displays properties from the environment.
| `/actuator/beans` | Lists all Spring Beans.
| `/actuator/mappings` | Shows all request mappings.
| `/actuator/loggers` | Shows and modifies log levels.
| `/actuator/threaddump` | Displays thread dump.
|===

*Enable Specific Endpoints in `application.properties`*

[source, properties]
----
management.endpoints.web.exposure.include=health,info,metrics,env
management.endpoint.health.show-details=always
----

*Customizing Info Endpoint*

You can add custom data to `/actuator/info`:

[source, properties]
----
info.app.name=My Spring Boot App
info.app.version=1.0.0
info.app.author=John Doe
----

Then access via: `GET /actuator/info`

*Securing Endpoints*

To secure actuator endpoints, include Spring Security and configure access:

[source, xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
----

Then configure access control in your security config.

*Tips*

* Use `curl http://localhost:8080/actuator` to explore endpoints.
* Use `/actuator/metrics` to monitor performance.
* Use `/actuator/health` for service readiness/liveness probes in Kubernetes.


##############################################

== Spring Boot Controller

Spring Boot controllers are used to handle web requests and return responses in a RESTful or web application.

*Key Annotations*

[cols="1,3", options="header"]
|===
| Annotation | Purpose

| `@RestController`
| Combines `@Controller` and `@ResponseBody`. Indicates that the class handles RESTful web requests and returns JSON/XML responses.

| `@RequestMapping`
| Maps HTTP requests to handler methods (e.g., GET, POST, etc.).

| `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`
| Specialized annotations for HTTP methods.

| `@PathVariable`
| Extracts values from the URI.

| `@RequestParam`
| Extracts query parameters from the request URL.

| `@RequestBody`
| Binds the request body to a Java object.
|===

*Example: Simple REST Controller*

[source,java]
----
@RestController
@RequestMapping("/api")
public class HelloController {

    @GetMapping("/hello")
    public String sayHello() {
        return "Hello, World!";
    }

    @GetMapping("/greet/{name}")
    public String greet(@PathVariable String name) {
        return "Hello, " + name + "!";
    }

    @PostMapping("/echo")
    public String echo(@RequestBody String message) {
        return "You said: " + message;
    }
}
----

*Summary*

* `@RestController` is the backbone of building REST APIs in Spring Boot.
* It allows you to map web requests directly to Java methods.
* Data is typically returned in JSON format.
* Annotations simplify mapping request parameters and bodies to Java objects.


##############################################


== Spring Boot Repositories

Spring Boot simplifies database access using the Spring Data JPA repository abstraction. It provides a way to perform CRUD operations and query the database with minimal boilerplate code.

*Key Concepts*

[cols="1,3", options="header"]
|===
| Concept | Description

| `@Repository`
| Marks a class as a repository, which is a mechanism for encapsulating storage, retrieval, and search behavior.

| `CrudRepository<T, ID>`
| Provides CRUD functions such as `save()`, `findById()`, `deleteById()`, etc.

| `JpaRepository<T, ID>`
| Extends `CrudRepository` and adds JPA-specific methods like pagination and batch operations.

| `@EnableJpaRepositories`
| Enables scanning for repository interfaces (usually configured automatically by Spring Boot).
|===

*Example: Repository Interface*

[source,java]
----
import org.springframework.data.jpa.repository.JpaRepository;

public interface BookRepository extends JpaRepository<Book, Long> {
    // You can define custom queries here
    List<Book> findByAuthor(String author);
}
----

*Example: Entity Class*

[source,java]
----
import jakarta.persistence.*;

@Entity
public class Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String author;

    // Getters and Setters
}
----

*Using Repository in a Service*

[source,java]
----
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class BookService {

    @Autowired
    private BookRepository bookRepository;

    public List<Book> getAllBooks() {
        return bookRepository.findAll();
    }

    public Book saveBook(Book book) {
        return bookRepository.save(book);
    }
}
----

*Summary*

* Spring Boot repositories abstract database access logic.
* Common operations (`findAll`, `save`, `deleteById`, etc.) are already implemented.
* Custom methods can be defined using query method naming conventions.
* `JpaRepository` provides advanced JPA features like sorting and pagination.


##############################################



== Spring Boot Mini Project

1. *Introduction to Spring Boot*

* What is Spring Boot?
* How it differs from Spring Core?
* Benefits: Auto-configuration, Starter Dependencies, Embedded Server

2. *Spring Boot Project Setup*

* Creating project using Spring Initializr (Web, JPA, DevTools, etc.)
* Project structure and files explained
* Running a Spring Boot application

3. *Spring Boot Annotations*

* `@SpringBootApplication`
* `@RestController`, `@RequestMapping`, `@GetMapping`, `@PostMapping`
* `@Component`, `@Service`, `@Repository`

4. *REST API with Spring Boot*

* Creating simple REST endpoints
* Handling GET, POST, PUT, DELETE
* Using `@PathVariable` and `@RequestBody`

5. *Spring Boot with JPA & Hibernate*

* Introduction to Spring Data JPA
* Creating `@Entity` classes
* `JpaRepository` and CRUD operations
* Auto-generating schema with `spring.jpa.hibernate.ddl-auto`

6. *Connecting to Databases*

* Using H2 (in-memory) for development
* Switching to MySQL/PostgreSQL
* Understanding `application.properties` or `application.yml`

7. *Validation and Exception Handling*

* Using `@Valid` and `@NotNull`, `@Size`, etc.
* Global exception handling with `@ControllerAdvice`

8. *Spring Boot DevTools and Hot Reload*

* Enabling DevTools
* Using Spring Boot DevTools for better development experience

9. *Spring Boot Configuration*

* Externalized configuration using `application.properties`
* Profiles: `application-dev.properties`, `application-prod.properties`
* Use of `@Value` and `@ConfigurationProperties`

10. *Spring Boot Logging*

* Default logging in Spring Boot
* Log levels and customizing logs via properties

11. *Spring Boot Testing (Optional for advanced batch)*

* Introduction to testing with `@SpringBootTest`
* Writing unit tests for controllers/services

12. *Project/Assignment*

* Build a mini full-stack project (e.g., Book Store, Task Manager)
* Include REST API, JPA, validation, and exception handling

---


[source,java]
----

// File: BookAppApplication.java
package com.example.bookapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BookAppApplication {
    public static void main(String[] args) {
        SpringApplication.run(BookAppApplication.class, args);
    }
}

// File: entity/Book.java
package com.example.bookapp.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Entity
public class Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Title is mandatory")
    @Size(min = 2, message = "Title must have at least 2 characters")
    private String title;

    @NotBlank(message = "Author is mandatory")
    private String author;

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    public String getAuthor() { return author; }
    public void setAuthor(String author) { this.author = author; }
}



// File: repository/BookRepository.java
package com.example.bookapp.repository;

import com.example.bookapp.entity.Book;
import org.springframework.data.jpa.repository.JpaRepository;

public interface BookRepository extends JpaRepository<Book, Long> {
}

// File: service/BookService.java
package com.example.bookapp.service;

import com.example.bookapp.entity.Book;
import com.example.bookapp.exception.ResourceNotFoundException;
import com.example.bookapp.repository.BookRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class BookService {

    private final BookRepository bookRepository;

    public BookService(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

    public List<Book> getAllBooks() {
        return bookRepository.findAll();
    }

    public Book getBookById(Long id) {
        return bookRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Book not found with id " + id));
    }

    public Book createBook(Book book) {
        return bookRepository.save(book);
    }

    public Book updateBook(Long id, Book updatedBook) {
        Book book = getBookById(id);
        book.setTitle(updatedBook.getTitle());
        book.setAuthor(updatedBook.getAuthor());
        return bookRepository.save(book);
    }

    public void deleteBook(Long id) {
        Book book = getBookById(id);
        bookRepository.delete(book);
    }
}

// File: controller/BookController.java
package com.example.bookapp.controller;

import com.example.bookapp.entity.Book;
import com.example.bookapp.service.BookService;
import jakarta.validation.Valid;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/books")
public class BookController {

    private final BookService bookService;

    public BookController(BookService bookService) {
        this.bookService = bookService;
    }

    @GetMapping
    public List<Book> getAllBooks() {
        return bookService.getAllBooks();
    }

    @GetMapping("/{id}")
    public Book getBookById(@PathVariable Long id) {
        return bookService.getBookById(id);
    }

    @PostMapping
    public Book createBook(@Valid @RequestBody Book book) {
        return bookService.createBook(book);
    }

    @PutMapping("/{id}")
    public Book updateBook(@PathVariable Long id, @Valid @RequestBody Book book) {
        return bookService.updateBook(id, book);
    }

    @DeleteMapping("/{id}")
    public void deleteBook(@PathVariable Long id) {
        bookService.deleteBook(id);
    }
}

----

[source,java]
----
// File: exception/ResourceNotFoundException.java
package com.example.bookapp.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

// File: exception/GlobalExceptionHandler.java
package com.example.bookapp.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationErrors(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
                errors.put(error.getField(), error.getDefaultMessage()));
        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }
}
----

[source,properties]
----
// File: application.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
spring.jpa.hibernate.ddl-auto=update
logging.level.org.springframework=INFO
----


[source,xml]
----
// File: pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>bookapp</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    <name>Book App</name>
    <description>Sample Spring Boot Project with H2 DB</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.3</version>
    </parent>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>jakarta.validation</groupId>
            <artifactId>jakarta.validation-api</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
----